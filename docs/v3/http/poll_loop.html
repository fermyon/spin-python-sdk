<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>spin_sdk.http.poll_loop API documentation</title>
<meta name="description" content="Defines a custom `asyncio` event loop backed by `wasi:io/poll#poll` …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spin_sdk.http.poll_loop</code></h1>
</header>
<section id="section-intro">
<p>Defines a custom <code>asyncio</code> event loop backed by <code>wasi:io/poll#poll</code>.</p>
<p>This also includes helper classes and functions for working with <code>wasi:http</code>.</p>
<p>As of WASI Preview 2, there is not yet a standard for first-class, composable
asynchronous functions and streams.
We expect that little or none of this
boilerplate will be needed once those features arrive in Preview 3.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Defines a custom `asyncio` event loop backed by `wasi:io/poll#poll`.

This also includes helper classes and functions for working with `wasi:http`.

As of WASI Preview 2, there is not yet a standard for first-class, composable
asynchronous functions and streams.  We expect that little or none of this
boilerplate will be needed once those features arrive in Preview 3.
&#34;&#34;&#34;

import asyncio
import socket
import subprocess

from spin_sdk.wit.types import Ok, Err
from spin_sdk.wit.imports import types, streams, poll, outgoing_handler
from spin_sdk.wit.imports.types import IncomingBody, OutgoingBody, OutgoingRequest, IncomingResponse
from spin_sdk.wit.imports.streams import StreamError_Closed, InputStream
from spin_sdk.wit.imports.poll import Pollable
from typing import Optional, cast

# Maximum number of bytes to read at a time
READ_SIZE: int = 16 * 1024

async def send(request: OutgoingRequest) -&gt; IncomingResponse:
    &#34;&#34;&#34;Send the specified request and wait asynchronously for the response.&#34;&#34;&#34;
    
    future = outgoing_handler.handle(request, None)

    while True:
        response = future.get()
        if response is None:
            await register(cast(PollLoop, asyncio.get_event_loop()), future.subscribe())
        else:
            future.__exit__()
            
            if isinstance(response, Ok):
                if isinstance(response.value, Ok):
                    return response.value.value
                else:
                    raise response.value
            else:
                raise response

class Stream:
    &#34;&#34;&#34;Reader abstraction over `wasi:http/types#incoming-body`.&#34;&#34;&#34;
    def __init__(self, body: IncomingBody):
        self.body: Optional[IncomingBody] = body
        self.stream: Optional[InputStream] = body.stream()

    async def next(self) -&gt; Optional[bytes]:
        &#34;&#34;&#34;Wait for the next chunk of data to arrive on the stream.

        This will return `None` when the end of the stream has been reached.
        &#34;&#34;&#34;
        while True:
            try:
                if self.stream is None:
                    return None
                else:
                    buffer = self.stream.read(READ_SIZE)
                    if len(buffer) == 0:
                        await register(cast(PollLoop, asyncio.get_event_loop()), self.stream.subscribe())
                    else:
                        return buffer
            except Err as e:
                if isinstance(e.value, StreamError_Closed):
                    if self.stream is not None:
                        self.stream.__exit__()
                        self.stream = None
                    if self.body is not None:
                        IncomingBody.finish(self.body)
                        self.body = None
                else:
                    raise e

class Sink:
    &#34;&#34;&#34;Writer abstraction over `wasi-http/types#outgoing-body`.&#34;&#34;&#34;
    def __init__(self, body: OutgoingBody):
        self.body = body
        self.stream = body.write()

    async def send(self, chunk: bytes):
        &#34;&#34;&#34;Write the specified bytes to the sink.

        This may need to yield according to the backpressure requirements of the sink.
        &#34;&#34;&#34;
        offset = 0
        flushing = False
        while True:
            count = self.stream.check_write()
            if count == 0:
                await register(cast(PollLoop, asyncio.get_event_loop()), self.stream.subscribe())
            elif offset == len(chunk):
                if flushing:
                    return
                else:
                    self.stream.flush()
                    flushing = True
            else:
                count = min(count, len(chunk) - offset)
                self.stream.write(chunk[offset:offset+count])
                offset += count

    def close(self):
        &#34;&#34;&#34;Close the stream, indicating no further data will be written.&#34;&#34;&#34;

        self.stream.__exit__()
        self.stream = None
        OutgoingBody.finish(self.body, None)
        self.body = None
        
class PollLoop(asyncio.AbstractEventLoop):
    &#34;&#34;&#34;Custom `asyncio` event loop backed by `wasi:io/poll#poll`.&#34;&#34;&#34;
    
    def __init__(self):
        self.wakers = []
        self.running = False
        self.handles = []
        self.exception = None

    def get_debug(self):
        return False

    def run_until_complete(self, future):
        future = asyncio.ensure_future(future, loop=self)

        self.running = True
        asyncio.events._set_running_loop(self)
        while self.running and not future.done():
            handle = self.handles[0]
            self.handles = self.handles[1:]
            if not handle._cancelled:
                handle._run()
                
            if self.wakers:
                [pollables, wakers] = list(map(list, zip(*self.wakers)))
                
                new_wakers = []
                ready = [False] * len(pollables)
                for index in poll.poll(pollables):
                    ready[index] = True
                
                for (ready, pollable), waker in zip(zip(ready, pollables), wakers):
                    if ready:
                        pollable.__exit__()
                        waker.set_result(None)
                    else:
                        new_wakers.append((pollable, waker))

                self.wakers = new_wakers

            if self.exception is not None:
                raise self.exception
            
        return future.result()

    def is_running(self):
        return self.running

    def is_closed(self):
        return not self.running

    def stop(self):
        self.running = False

    def close(self):
        self.running = False

    def shutdown_asyncgens(self):
        pass

    def call_exception_handler(self, context):
        self.exception = context.get(&#39;exception&#39;, None)

    def call_soon(self, callback, *args, context=None):
        handle = asyncio.Handle(callback, args, self, context)
        self.handles.append(handle)
        return handle

    def create_task(self, coroutine):
        return asyncio.Task(coroutine, loop=self)

    def create_future(self):
        return asyncio.Future(loop=self)

    # The remaining methods should be irrelevant for our purposes and thus unimplemented

    def run_forever(self):
        raise NotImplementedError

    async def shutdown_default_executor(self):
        raise NotImplementedError

    def _timer_handle_cancelled(self, handle):
        raise NotImplementedError

    def call_later(self, delay, callback, *args, context=None):
        raise NotImplementedError

    def call_at(self, when, callback, *args, context=None):
        raise NotImplementedError

    def time(self):
        raise NotImplementedError

    def call_soon_threadsafe(self, callback, *args, context=None):
        raise NotImplementedError

    def run_in_executor(self, executor, func, *args):
        raise NotImplementedError

    def set_default_executor(self, executor):
        raise NotImplementedError

    async def getaddrinfo(self, host, port, *,
                          family=0, type=0, proto=0, flags=0):
        raise NotImplementedError

    async def getnameinfo(self, sockaddr, flags=0):
        raise NotImplementedError

    async def create_connection(
            self, protocol_factory, host=None, port=None,
            *, ssl=None, family=0, proto=0,
            flags=0, sock=None, local_addr=None,
            server_hostname=None,
            ssl_handshake_timeout=None,
            ssl_shutdown_timeout=None,
            happy_eyeballs_delay=None, interleave=None):
        raise NotImplementedError

    async def create_server(
            self, protocol_factory, host=None, port=None,
            *, family=socket.AF_UNSPEC,
            flags=socket.AI_PASSIVE, sock=None, backlog=100,
            ssl=None, reuse_address=None, reuse_port=None,
            ssl_handshake_timeout=None,
            ssl_shutdown_timeout=None,
            start_serving=True):
        raise NotImplementedError

    async def sendfile(self, transport, file, offset=0, count=None,
                       *, fallback=True):
        raise NotImplementedError

    async def start_tls(self, transport, protocol, sslcontext, *,
                        server_side=False,
                        server_hostname=None,
                        ssl_handshake_timeout=None,
                        ssl_shutdown_timeout=None):
        raise NotImplementedError

    async def create_unix_connection(
            self, protocol_factory, path=None, *,
            ssl=None, sock=None,
            server_hostname=None,
            ssl_handshake_timeout=None,
            ssl_shutdown_timeout=None):
        raise NotImplementedError

    async def create_unix_server(
            self, protocol_factory, path=None, *,
            sock=None, backlog=100, ssl=None,
            ssl_handshake_timeout=None,
            ssl_shutdown_timeout=None,
            start_serving=True):
        raise NotImplementedError

    async def connect_accepted_socket(
            self, protocol_factory, sock,
            *, ssl=None,
            ssl_handshake_timeout=None,
            ssl_shutdown_timeout=None):
        raise NotImplementedError

    async def create_datagram_endpoint(self, protocol_factory,
                                       local_addr=None, remote_addr=None, *,
                                       family=0, proto=0, flags=0,
                                       reuse_address=None, reuse_port=None,
                                       allow_broadcast=None, sock=None):
        raise NotImplementedError

    async def connect_read_pipe(self, protocol_factory, pipe):
        raise NotImplementedError

    async def connect_write_pipe(self, protocol_factory, pipe):
        raise NotImplementedError

    async def subprocess_shell(self, protocol_factory, cmd, *,
                               stdin=subprocess.PIPE,
                               stdout=subprocess.PIPE,
                               stderr=subprocess.PIPE,
                               **kwargs):
        raise NotImplementedError

    async def subprocess_exec(self, protocol_factory, *args,
                              stdin=subprocess.PIPE,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.PIPE,
                              **kwargs):
        raise NotImplementedError

    def add_reader(self, fd, callback, *args):
        raise NotImplementedError

    def remove_reader(self, fd):
        raise NotImplementedError

    def add_writer(self, fd, callback, *args):
        raise NotImplementedError

    def remove_writer(self, fd):
        raise NotImplementedError

    async def sock_recv(self, sock, nbytes):
        raise NotImplementedError

    async def sock_recv_into(self, sock, buf):
        raise NotImplementedError

    async def sock_recvfrom(self, sock, bufsize):
        raise NotImplementedError

    async def sock_recvfrom_into(self, sock, buf, nbytes=0):
        raise NotImplementedError

    async def sock_sendall(self, sock, data):
        raise NotImplementedError

    async def sock_sendto(self, sock, data, address):
        raise NotImplementedError

    async def sock_connect(self, sock, address):
        raise NotImplementedError

    async def sock_accept(self, sock):
        raise NotImplementedError

    async def sock_sendfile(self, sock, file, offset=0, count=None,
                            *, fallback=None):
        raise NotImplementedError

    def add_signal_handler(self, sig, callback, *args):
        raise NotImplementedError

    def remove_signal_handler(self, sig):
        raise NotImplementedError

    def set_task_factory(self, factory):
        raise NotImplementedError

    def get_task_factory(self):
        raise NotImplementedError

    def get_exception_handler(self):
        raise NotImplementedError

    def set_exception_handler(self, handler):
        raise NotImplementedError

    def default_exception_handler(self, context):
        raise NotImplementedError

    def set_debug(self, enabled):
        raise NotImplementedError

async def register(loop: PollLoop, pollable: Pollable):
    waker = loop.create_future()
    loop.wakers.append((pollable, waker))
    await waker</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="spin_sdk.http.poll_loop.register"><code class="name flex">
<span>async def <span class="ident">register</span></span>(<span>loop: <a title="spin_sdk.http.poll_loop.PollLoop" href="#spin_sdk.http.poll_loop.PollLoop">PollLoop</a>, pollable: <a title="spin_sdk.wit.imports.poll.Pollable" href="../wit/imports/poll.html#spin_sdk.wit.imports.poll.Pollable">Pollable</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def register(loop: PollLoop, pollable: Pollable):
    waker = loop.create_future()
    loop.wakers.append((pollable, waker))
    await waker</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.send"><code class="name flex">
<span>async def <span class="ident">send</span></span>(<span>request: <a title="spin_sdk.wit.imports.types.OutgoingRequest" href="../wit/imports/types.html#spin_sdk.wit.imports.types.OutgoingRequest">OutgoingRequest</a>) ‑> <a title="spin_sdk.wit.imports.types.IncomingResponse" href="../wit/imports/types.html#spin_sdk.wit.imports.types.IncomingResponse">IncomingResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Send the specified request and wait asynchronously for the response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send(request: OutgoingRequest) -&gt; IncomingResponse:
    &#34;&#34;&#34;Send the specified request and wait asynchronously for the response.&#34;&#34;&#34;
    
    future = outgoing_handler.handle(request, None)

    while True:
        response = future.get()
        if response is None:
            await register(cast(PollLoop, asyncio.get_event_loop()), future.subscribe())
        else:
            future.__exit__()
            
            if isinstance(response, Ok):
                if isinstance(response.value, Ok):
                    return response.value.value
                else:
                    raise response.value
            else:
                raise response</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="spin_sdk.http.poll_loop.PollLoop"><code class="flex name class">
<span>class <span class="ident">PollLoop</span></span>
</code></dt>
<dd>
<div class="desc"><p>Custom <code>asyncio</code> event loop backed by <code>wasi:io/poll#poll</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PollLoop(asyncio.AbstractEventLoop):
    &#34;&#34;&#34;Custom `asyncio` event loop backed by `wasi:io/poll#poll`.&#34;&#34;&#34;
    
    def __init__(self):
        self.wakers = []
        self.running = False
        self.handles = []
        self.exception = None

    def get_debug(self):
        return False

    def run_until_complete(self, future):
        future = asyncio.ensure_future(future, loop=self)

        self.running = True
        asyncio.events._set_running_loop(self)
        while self.running and not future.done():
            handle = self.handles[0]
            self.handles = self.handles[1:]
            if not handle._cancelled:
                handle._run()
                
            if self.wakers:
                [pollables, wakers] = list(map(list, zip(*self.wakers)))
                
                new_wakers = []
                ready = [False] * len(pollables)
                for index in poll.poll(pollables):
                    ready[index] = True
                
                for (ready, pollable), waker in zip(zip(ready, pollables), wakers):
                    if ready:
                        pollable.__exit__()
                        waker.set_result(None)
                    else:
                        new_wakers.append((pollable, waker))

                self.wakers = new_wakers

            if self.exception is not None:
                raise self.exception
            
        return future.result()

    def is_running(self):
        return self.running

    def is_closed(self):
        return not self.running

    def stop(self):
        self.running = False

    def close(self):
        self.running = False

    def shutdown_asyncgens(self):
        pass

    def call_exception_handler(self, context):
        self.exception = context.get(&#39;exception&#39;, None)

    def call_soon(self, callback, *args, context=None):
        handle = asyncio.Handle(callback, args, self, context)
        self.handles.append(handle)
        return handle

    def create_task(self, coroutine):
        return asyncio.Task(coroutine, loop=self)

    def create_future(self):
        return asyncio.Future(loop=self)

    # The remaining methods should be irrelevant for our purposes and thus unimplemented

    def run_forever(self):
        raise NotImplementedError

    async def shutdown_default_executor(self):
        raise NotImplementedError

    def _timer_handle_cancelled(self, handle):
        raise NotImplementedError

    def call_later(self, delay, callback, *args, context=None):
        raise NotImplementedError

    def call_at(self, when, callback, *args, context=None):
        raise NotImplementedError

    def time(self):
        raise NotImplementedError

    def call_soon_threadsafe(self, callback, *args, context=None):
        raise NotImplementedError

    def run_in_executor(self, executor, func, *args):
        raise NotImplementedError

    def set_default_executor(self, executor):
        raise NotImplementedError

    async def getaddrinfo(self, host, port, *,
                          family=0, type=0, proto=0, flags=0):
        raise NotImplementedError

    async def getnameinfo(self, sockaddr, flags=0):
        raise NotImplementedError

    async def create_connection(
            self, protocol_factory, host=None, port=None,
            *, ssl=None, family=0, proto=0,
            flags=0, sock=None, local_addr=None,
            server_hostname=None,
            ssl_handshake_timeout=None,
            ssl_shutdown_timeout=None,
            happy_eyeballs_delay=None, interleave=None):
        raise NotImplementedError

    async def create_server(
            self, protocol_factory, host=None, port=None,
            *, family=socket.AF_UNSPEC,
            flags=socket.AI_PASSIVE, sock=None, backlog=100,
            ssl=None, reuse_address=None, reuse_port=None,
            ssl_handshake_timeout=None,
            ssl_shutdown_timeout=None,
            start_serving=True):
        raise NotImplementedError

    async def sendfile(self, transport, file, offset=0, count=None,
                       *, fallback=True):
        raise NotImplementedError

    async def start_tls(self, transport, protocol, sslcontext, *,
                        server_side=False,
                        server_hostname=None,
                        ssl_handshake_timeout=None,
                        ssl_shutdown_timeout=None):
        raise NotImplementedError

    async def create_unix_connection(
            self, protocol_factory, path=None, *,
            ssl=None, sock=None,
            server_hostname=None,
            ssl_handshake_timeout=None,
            ssl_shutdown_timeout=None):
        raise NotImplementedError

    async def create_unix_server(
            self, protocol_factory, path=None, *,
            sock=None, backlog=100, ssl=None,
            ssl_handshake_timeout=None,
            ssl_shutdown_timeout=None,
            start_serving=True):
        raise NotImplementedError

    async def connect_accepted_socket(
            self, protocol_factory, sock,
            *, ssl=None,
            ssl_handshake_timeout=None,
            ssl_shutdown_timeout=None):
        raise NotImplementedError

    async def create_datagram_endpoint(self, protocol_factory,
                                       local_addr=None, remote_addr=None, *,
                                       family=0, proto=0, flags=0,
                                       reuse_address=None, reuse_port=None,
                                       allow_broadcast=None, sock=None):
        raise NotImplementedError

    async def connect_read_pipe(self, protocol_factory, pipe):
        raise NotImplementedError

    async def connect_write_pipe(self, protocol_factory, pipe):
        raise NotImplementedError

    async def subprocess_shell(self, protocol_factory, cmd, *,
                               stdin=subprocess.PIPE,
                               stdout=subprocess.PIPE,
                               stderr=subprocess.PIPE,
                               **kwargs):
        raise NotImplementedError

    async def subprocess_exec(self, protocol_factory, *args,
                              stdin=subprocess.PIPE,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.PIPE,
                              **kwargs):
        raise NotImplementedError

    def add_reader(self, fd, callback, *args):
        raise NotImplementedError

    def remove_reader(self, fd):
        raise NotImplementedError

    def add_writer(self, fd, callback, *args):
        raise NotImplementedError

    def remove_writer(self, fd):
        raise NotImplementedError

    async def sock_recv(self, sock, nbytes):
        raise NotImplementedError

    async def sock_recv_into(self, sock, buf):
        raise NotImplementedError

    async def sock_recvfrom(self, sock, bufsize):
        raise NotImplementedError

    async def sock_recvfrom_into(self, sock, buf, nbytes=0):
        raise NotImplementedError

    async def sock_sendall(self, sock, data):
        raise NotImplementedError

    async def sock_sendto(self, sock, data, address):
        raise NotImplementedError

    async def sock_connect(self, sock, address):
        raise NotImplementedError

    async def sock_accept(self, sock):
        raise NotImplementedError

    async def sock_sendfile(self, sock, file, offset=0, count=None,
                            *, fallback=None):
        raise NotImplementedError

    def add_signal_handler(self, sig, callback, *args):
        raise NotImplementedError

    def remove_signal_handler(self, sig):
        raise NotImplementedError

    def set_task_factory(self, factory):
        raise NotImplementedError

    def get_task_factory(self):
        raise NotImplementedError

    def get_exception_handler(self):
        raise NotImplementedError

    def set_exception_handler(self, handler):
        raise NotImplementedError

    def default_exception_handler(self, context):
        raise NotImplementedError

    def set_debug(self, enabled):
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>asyncio.events.AbstractEventLoop</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="spin_sdk.http.poll_loop.PollLoop.add_reader"><code class="name flex">
<span>def <span class="ident">add_reader</span></span>(<span>self, fd, callback, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_reader(self, fd, callback, *args):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.add_signal_handler"><code class="name flex">
<span>def <span class="ident">add_signal_handler</span></span>(<span>self, sig, callback, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_signal_handler(self, sig, callback, *args):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.add_writer"><code class="name flex">
<span>def <span class="ident">add_writer</span></span>(<span>self, fd, callback, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_writer(self, fd, callback, *args):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.call_at"><code class="name flex">
<span>def <span class="ident">call_at</span></span>(<span>self, when, callback, *args, context=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_at(self, when, callback, *args, context=None):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.call_exception_handler"><code class="name flex">
<span>def <span class="ident">call_exception_handler</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_exception_handler(self, context):
    self.exception = context.get(&#39;exception&#39;, None)</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.call_later"><code class="name flex">
<span>def <span class="ident">call_later</span></span>(<span>self, delay, callback, *args, context=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_later(self, delay, callback, *args, context=None):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.call_soon"><code class="name flex">
<span>def <span class="ident">call_soon</span></span>(<span>self, callback, *args, context=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_soon(self, callback, *args, context=None):
    handle = asyncio.Handle(callback, args, self, context)
    self.handles.append(handle)
    return handle</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.call_soon_threadsafe"><code class="name flex">
<span>def <span class="ident">call_soon_threadsafe</span></span>(<span>self, callback, *args, context=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_soon_threadsafe(self, callback, *args, context=None):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close the loop.</p>
<p>The loop should not be running.</p>
<p>This is idempotent and irreversible.</p>
<p>No other methods should be called after this one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    self.running = False</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.connect_accepted_socket"><code class="name flex">
<span>async def <span class="ident">connect_accepted_socket</span></span>(<span>self, protocol_factory, sock, *, ssl=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle an accepted connection.</p>
<p>This is used by servers that accept connections outside of
asyncio, but use asyncio to handle connections.</p>
<p>This method is a coroutine.
When completed, the coroutine
returns a (transport, protocol) pair.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect_accepted_socket(
        self, protocol_factory, sock,
        *, ssl=None,
        ssl_handshake_timeout=None,
        ssl_shutdown_timeout=None):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.connect_read_pipe"><code class="name flex">
<span>async def <span class="ident">connect_read_pipe</span></span>(<span>self, protocol_factory, pipe)</span>
</code></dt>
<dd>
<div class="desc"><p>Register read pipe in event loop. Set the pipe to non-blocking mode.</p>
<p>protocol_factory should instantiate object with Protocol interface.
pipe is a file-like object.
Return pair (transport, protocol), where transport supports the
ReadTransport interface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect_read_pipe(self, protocol_factory, pipe):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.connect_write_pipe"><code class="name flex">
<span>async def <span class="ident">connect_write_pipe</span></span>(<span>self, protocol_factory, pipe)</span>
</code></dt>
<dd>
<div class="desc"><p>Register write pipe in event loop.</p>
<p>protocol_factory should instantiate object with BaseProtocol interface.
Pipe is file-like object already switched to nonblocking.
Return pair (transport, protocol), where transport support
WriteTransport interface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect_write_pipe(self, protocol_factory, pipe):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.create_connection"><code class="name flex">
<span>async def <span class="ident">create_connection</span></span>(<span>self, protocol_factory, host=None, port=None, *, ssl=None, family=0, proto=0, flags=0, sock=None, local_addr=None, server_hostname=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None, happy_eyeballs_delay=None, interleave=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def create_connection(
        self, protocol_factory, host=None, port=None,
        *, ssl=None, family=0, proto=0,
        flags=0, sock=None, local_addr=None,
        server_hostname=None,
        ssl_handshake_timeout=None,
        ssl_shutdown_timeout=None,
        happy_eyeballs_delay=None, interleave=None):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.create_datagram_endpoint"><code class="name flex">
<span>async def <span class="ident">create_datagram_endpoint</span></span>(<span>self, protocol_factory, local_addr=None, remote_addr=None, *, family=0, proto=0, flags=0, reuse_address=None, reuse_port=None, allow_broadcast=None, sock=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A coroutine which creates a datagram endpoint.</p>
<p>This method will try to establish the endpoint in the background.
When successful, the coroutine returns a (transport, protocol) pair.</p>
<p>protocol_factory must be a callable returning a protocol instance.</p>
<p>socket family AF_INET, socket.AF_INET6 or socket.AF_UNIX depending on
host (or family if specified), socket type SOCK_DGRAM.</p>
<p>reuse_address tells the kernel to reuse a local socket in
TIME_WAIT state, without waiting for its natural timeout to
expire. If not specified it will automatically be set to True on
UNIX.</p>
<p>reuse_port tells the kernel to allow this endpoint to be bound to
the same port as other existing endpoints are bound to, so long as
they all set this flag when being created. This option is not
supported on Windows and some UNIX's. If the
:py:data:<code>~socket.SO_REUSEPORT</code> constant is not defined then this
capability is unsupported.</p>
<p>allow_broadcast tells the kernel to allow this endpoint to send
messages to the broadcast address.</p>
<p>sock can optionally be specified in order to use a preexisting
socket object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def create_datagram_endpoint(self, protocol_factory,
                                   local_addr=None, remote_addr=None, *,
                                   family=0, proto=0, flags=0,
                                   reuse_address=None, reuse_port=None,
                                   allow_broadcast=None, sock=None):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.create_future"><code class="name flex">
<span>def <span class="ident">create_future</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_future(self):
    return asyncio.Future(loop=self)</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.create_server"><code class="name flex">
<span>async def <span class="ident">create_server</span></span>(<span>self, protocol_factory, host=None, port=None, *, family=0, flags=1, sock=None, backlog=100, ssl=None, reuse_address=None, reuse_port=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None, start_serving=True)</span>
</code></dt>
<dd>
<div class="desc"><p>A coroutine which creates a TCP server bound to host and port.</p>
<p>The return value is a Server object which can be used to stop
the service.</p>
<p>If host is an empty string or None all interfaces are assumed
and a list of multiple sockets will be returned (most likely
one for IPv4 and another one for IPv6). The host parameter can also be
a sequence (e.g. list) of hosts to bind to.</p>
<p>family can be set to either AF_INET or AF_INET6 to force the
socket to use IPv4 or IPv6. If not set it will be determined
from host (defaults to AF_UNSPEC).</p>
<p>flags is a bitmask for getaddrinfo().</p>
<p>sock can optionally be specified in order to use a preexisting
socket object.</p>
<p>backlog is the maximum number of queued connections passed to
listen() (defaults to 100).</p>
<p>ssl can be set to an SSLContext to enable SSL over the
accepted connections.</p>
<p>reuse_address tells the kernel to reuse a local socket in
TIME_WAIT state, without waiting for its natural timeout to
expire. If not specified will automatically be set to True on
UNIX.</p>
<p>reuse_port tells the kernel to allow this endpoint to be bound to
the same port as other existing endpoints are bound to, so long as
they all set this flag when being created. This option is not
supported on Windows.</p>
<p>ssl_handshake_timeout is the time in seconds that an SSL server
will wait for completion of the SSL handshake before aborting the
connection. Default is 60s.</p>
<p>ssl_shutdown_timeout is the time in seconds that an SSL server
will wait for completion of the SSL shutdown procedure
before aborting the connection. Default is 30s.</p>
<p>start_serving set to True (default) causes the created server
to start accepting connections immediately.
When set to False,
the user should await Server.start_serving() or Server.serve_forever()
to make the server to start accepting connections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def create_server(
        self, protocol_factory, host=None, port=None,
        *, family=socket.AF_UNSPEC,
        flags=socket.AI_PASSIVE, sock=None, backlog=100,
        ssl=None, reuse_address=None, reuse_port=None,
        ssl_handshake_timeout=None,
        ssl_shutdown_timeout=None,
        start_serving=True):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.create_task"><code class="name flex">
<span>def <span class="ident">create_task</span></span>(<span>self, coroutine)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_task(self, coroutine):
    return asyncio.Task(coroutine, loop=self)</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.create_unix_connection"><code class="name flex">
<span>async def <span class="ident">create_unix_connection</span></span>(<span>self, protocol_factory, path=None, *, ssl=None, sock=None, server_hostname=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def create_unix_connection(
        self, protocol_factory, path=None, *,
        ssl=None, sock=None,
        server_hostname=None,
        ssl_handshake_timeout=None,
        ssl_shutdown_timeout=None):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.create_unix_server"><code class="name flex">
<span>async def <span class="ident">create_unix_server</span></span>(<span>self, protocol_factory, path=None, *, sock=None, backlog=100, ssl=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None, start_serving=True)</span>
</code></dt>
<dd>
<div class="desc"><p>A coroutine which creates a UNIX Domain Socket server.</p>
<p>The return value is a Server object, which can be used to stop
the service.</p>
<p>path is a str, representing a file system path to bind the
server socket to.</p>
<p>sock can optionally be specified in order to use a preexisting
socket object.</p>
<p>backlog is the maximum number of queued connections passed to
listen() (defaults to 100).</p>
<p>ssl can be set to an SSLContext to enable SSL over the
accepted connections.</p>
<p>ssl_handshake_timeout is the time in seconds that an SSL server
will wait for the SSL handshake to complete (defaults to 60s).</p>
<p>ssl_shutdown_timeout is the time in seconds that an SSL server
will wait for the SSL shutdown to finish (defaults to 30s).</p>
<p>start_serving set to True (default) causes the created server
to start accepting connections immediately.
When set to False,
the user should await Server.start_serving() or Server.serve_forever()
to make the server to start accepting connections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def create_unix_server(
        self, protocol_factory, path=None, *,
        sock=None, backlog=100, ssl=None,
        ssl_handshake_timeout=None,
        ssl_shutdown_timeout=None,
        start_serving=True):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.default_exception_handler"><code class="name flex">
<span>def <span class="ident">default_exception_handler</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_exception_handler(self, context):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.get_debug"><code class="name flex">
<span>def <span class="ident">get_debug</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_debug(self):
    return False</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.get_exception_handler"><code class="name flex">
<span>def <span class="ident">get_exception_handler</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_exception_handler(self):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.get_task_factory"><code class="name flex">
<span>def <span class="ident">get_task_factory</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_task_factory(self):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.getaddrinfo"><code class="name flex">
<span>async def <span class="ident">getaddrinfo</span></span>(<span>self, host, port, *, family=0, type=0, proto=0, flags=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def getaddrinfo(self, host, port, *,
                      family=0, type=0, proto=0, flags=0):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.getnameinfo"><code class="name flex">
<span>async def <span class="ident">getnameinfo</span></span>(<span>self, sockaddr, flags=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def getnameinfo(self, sockaddr, flags=0):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.is_closed"><code class="name flex">
<span>def <span class="ident">is_closed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the event loop was closed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_closed(self):
    return not self.running</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.is_running"><code class="name flex">
<span>def <span class="ident">is_running</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return whether the event loop is currently running.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_running(self):
    return self.running</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.remove_reader"><code class="name flex">
<span>def <span class="ident">remove_reader</span></span>(<span>self, fd)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_reader(self, fd):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.remove_signal_handler"><code class="name flex">
<span>def <span class="ident">remove_signal_handler</span></span>(<span>self, sig)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_signal_handler(self, sig):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.remove_writer"><code class="name flex">
<span>def <span class="ident">remove_writer</span></span>(<span>self, fd)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_writer(self, fd):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.run_forever"><code class="name flex">
<span>def <span class="ident">run_forever</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the event loop until stop() is called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_forever(self):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.run_in_executor"><code class="name flex">
<span>def <span class="ident">run_in_executor</span></span>(<span>self, executor, func, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_in_executor(self, executor, func, *args):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.run_until_complete"><code class="name flex">
<span>def <span class="ident">run_until_complete</span></span>(<span>self, future)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the event loop until a Future is done.</p>
<p>Return the Future's result, or raise its exception.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_until_complete(self, future):
    future = asyncio.ensure_future(future, loop=self)

    self.running = True
    asyncio.events._set_running_loop(self)
    while self.running and not future.done():
        handle = self.handles[0]
        self.handles = self.handles[1:]
        if not handle._cancelled:
            handle._run()
            
        if self.wakers:
            [pollables, wakers] = list(map(list, zip(*self.wakers)))
            
            new_wakers = []
            ready = [False] * len(pollables)
            for index in poll.poll(pollables):
                ready[index] = True
            
            for (ready, pollable), waker in zip(zip(ready, pollables), wakers):
                if ready:
                    pollable.__exit__()
                    waker.set_result(None)
                else:
                    new_wakers.append((pollable, waker))

            self.wakers = new_wakers

        if self.exception is not None:
            raise self.exception
        
    return future.result()</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.sendfile"><code class="name flex">
<span>async def <span class="ident">sendfile</span></span>(<span>self, transport, file, offset=0, count=None, *, fallback=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Send a file through a transport.</p>
<p>Return an amount of sent bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def sendfile(self, transport, file, offset=0, count=None,
                   *, fallback=True):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.set_debug"><code class="name flex">
<span>def <span class="ident">set_debug</span></span>(<span>self, enabled)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_debug(self, enabled):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.set_default_executor"><code class="name flex">
<span>def <span class="ident">set_default_executor</span></span>(<span>self, executor)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_default_executor(self, executor):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.set_exception_handler"><code class="name flex">
<span>def <span class="ident">set_exception_handler</span></span>(<span>self, handler)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_exception_handler(self, handler):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.set_task_factory"><code class="name flex">
<span>def <span class="ident">set_task_factory</span></span>(<span>self, factory)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_task_factory(self, factory):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.shutdown_asyncgens"><code class="name flex">
<span>def <span class="ident">shutdown_asyncgens</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Shutdown all active asynchronous generators.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shutdown_asyncgens(self):
    pass</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.shutdown_default_executor"><code class="name flex">
<span>async def <span class="ident">shutdown_default_executor</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Schedule the shutdown of the default executor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def shutdown_default_executor(self):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.sock_accept"><code class="name flex">
<span>async def <span class="ident">sock_accept</span></span>(<span>self, sock)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def sock_accept(self, sock):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.sock_connect"><code class="name flex">
<span>async def <span class="ident">sock_connect</span></span>(<span>self, sock, address)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def sock_connect(self, sock, address):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.sock_recv"><code class="name flex">
<span>async def <span class="ident">sock_recv</span></span>(<span>self, sock, nbytes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def sock_recv(self, sock, nbytes):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.sock_recv_into"><code class="name flex">
<span>async def <span class="ident">sock_recv_into</span></span>(<span>self, sock, buf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def sock_recv_into(self, sock, buf):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.sock_recvfrom"><code class="name flex">
<span>async def <span class="ident">sock_recvfrom</span></span>(<span>self, sock, bufsize)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def sock_recvfrom(self, sock, bufsize):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.sock_recvfrom_into"><code class="name flex">
<span>async def <span class="ident">sock_recvfrom_into</span></span>(<span>self, sock, buf, nbytes=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def sock_recvfrom_into(self, sock, buf, nbytes=0):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.sock_sendall"><code class="name flex">
<span>async def <span class="ident">sock_sendall</span></span>(<span>self, sock, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def sock_sendall(self, sock, data):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.sock_sendfile"><code class="name flex">
<span>async def <span class="ident">sock_sendfile</span></span>(<span>self, sock, file, offset=0, count=None, *, fallback=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def sock_sendfile(self, sock, file, offset=0, count=None,
                        *, fallback=None):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.sock_sendto"><code class="name flex">
<span>async def <span class="ident">sock_sendto</span></span>(<span>self, sock, data, address)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def sock_sendto(self, sock, data, address):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.start_tls"><code class="name flex">
<span>async def <span class="ident">start_tls</span></span>(<span>self, transport, protocol, sslcontext, *, server_side=False, server_hostname=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Upgrade a transport to TLS.</p>
<p>Return a new transport that <em>protocol</em> should start using
immediately.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def start_tls(self, transport, protocol, sslcontext, *,
                    server_side=False,
                    server_hostname=None,
                    ssl_handshake_timeout=None,
                    ssl_shutdown_timeout=None):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the event loop as soon as reasonable.</p>
<p>Exactly how soon that is may depend on the implementation, but
no more I/O callbacks should be scheduled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    self.running = False</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.subprocess_exec"><code class="name flex">
<span>async def <span class="ident">subprocess_exec</span></span>(<span>self, protocol_factory, *args, stdin=-1, stdout=-1, stderr=-1, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def subprocess_exec(self, protocol_factory, *args,
                          stdin=subprocess.PIPE,
                          stdout=subprocess.PIPE,
                          stderr=subprocess.PIPE,
                          **kwargs):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.subprocess_shell"><code class="name flex">
<span>async def <span class="ident">subprocess_shell</span></span>(<span>self, protocol_factory, cmd, *, stdin=-1, stdout=-1, stderr=-1, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def subprocess_shell(self, protocol_factory, cmd, *,
                           stdin=subprocess.PIPE,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE,
                           **kwargs):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.PollLoop.time"><code class="name flex">
<span>def <span class="ident">time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time(self):
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spin_sdk.http.poll_loop.Sink"><code class="flex name class">
<span>class <span class="ident">Sink</span></span>
<span>(</span><span>body: <a title="spin_sdk.wit.imports.types.OutgoingBody" href="../wit/imports/types.html#spin_sdk.wit.imports.types.OutgoingBody">OutgoingBody</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Writer abstraction over <code>wasi-http/types#outgoing-body</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sink:
    &#34;&#34;&#34;Writer abstraction over `wasi-http/types#outgoing-body`.&#34;&#34;&#34;
    def __init__(self, body: OutgoingBody):
        self.body = body
        self.stream = body.write()

    async def send(self, chunk: bytes):
        &#34;&#34;&#34;Write the specified bytes to the sink.

        This may need to yield according to the backpressure requirements of the sink.
        &#34;&#34;&#34;
        offset = 0
        flushing = False
        while True:
            count = self.stream.check_write()
            if count == 0:
                await register(cast(PollLoop, asyncio.get_event_loop()), self.stream.subscribe())
            elif offset == len(chunk):
                if flushing:
                    return
                else:
                    self.stream.flush()
                    flushing = True
            else:
                count = min(count, len(chunk) - offset)
                self.stream.write(chunk[offset:offset+count])
                offset += count

    def close(self):
        &#34;&#34;&#34;Close the stream, indicating no further data will be written.&#34;&#34;&#34;

        self.stream.__exit__()
        self.stream = None
        OutgoingBody.finish(self.body, None)
        self.body = None</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="spin_sdk.http.poll_loop.Sink.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close the stream, indicating no further data will be written.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;Close the stream, indicating no further data will be written.&#34;&#34;&#34;

    self.stream.__exit__()
    self.stream = None
    OutgoingBody.finish(self.body, None)
    self.body = None</code></pre>
</details>
</dd>
<dt id="spin_sdk.http.poll_loop.Sink.send"><code class="name flex">
<span>async def <span class="ident">send</span></span>(<span>self, chunk: bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Write the specified bytes to the sink.</p>
<p>This may need to yield according to the backpressure requirements of the sink.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send(self, chunk: bytes):
    &#34;&#34;&#34;Write the specified bytes to the sink.

    This may need to yield according to the backpressure requirements of the sink.
    &#34;&#34;&#34;
    offset = 0
    flushing = False
    while True:
        count = self.stream.check_write()
        if count == 0:
            await register(cast(PollLoop, asyncio.get_event_loop()), self.stream.subscribe())
        elif offset == len(chunk):
            if flushing:
                return
            else:
                self.stream.flush()
                flushing = True
        else:
            count = min(count, len(chunk) - offset)
            self.stream.write(chunk[offset:offset+count])
            offset += count</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spin_sdk.http.poll_loop.Stream"><code class="flex name class">
<span>class <span class="ident">Stream</span></span>
<span>(</span><span>body: <a title="spin_sdk.wit.imports.types.IncomingBody" href="../wit/imports/types.html#spin_sdk.wit.imports.types.IncomingBody">IncomingBody</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Reader abstraction over <code>wasi:http/types#incoming-body</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Stream:
    &#34;&#34;&#34;Reader abstraction over `wasi:http/types#incoming-body`.&#34;&#34;&#34;
    def __init__(self, body: IncomingBody):
        self.body: Optional[IncomingBody] = body
        self.stream: Optional[InputStream] = body.stream()

    async def next(self) -&gt; Optional[bytes]:
        &#34;&#34;&#34;Wait for the next chunk of data to arrive on the stream.

        This will return `None` when the end of the stream has been reached.
        &#34;&#34;&#34;
        while True:
            try:
                if self.stream is None:
                    return None
                else:
                    buffer = self.stream.read(READ_SIZE)
                    if len(buffer) == 0:
                        await register(cast(PollLoop, asyncio.get_event_loop()), self.stream.subscribe())
                    else:
                        return buffer
            except Err as e:
                if isinstance(e.value, StreamError_Closed):
                    if self.stream is not None:
                        self.stream.__exit__()
                        self.stream = None
                    if self.body is not None:
                        IncomingBody.finish(self.body)
                        self.body = None
                else:
                    raise e</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="spin_sdk.http.poll_loop.Stream.next"><code class="name flex">
<span>async def <span class="ident">next</span></span>(<span>self) ‑> Optional[bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for the next chunk of data to arrive on the stream.</p>
<p>This will return <code>None</code> when the end of the stream has been reached.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def next(self) -&gt; Optional[bytes]:
    &#34;&#34;&#34;Wait for the next chunk of data to arrive on the stream.

    This will return `None` when the end of the stream has been reached.
    &#34;&#34;&#34;
    while True:
        try:
            if self.stream is None:
                return None
            else:
                buffer = self.stream.read(READ_SIZE)
                if len(buffer) == 0:
                    await register(cast(PollLoop, asyncio.get_event_loop()), self.stream.subscribe())
                else:
                    return buffer
        except Err as e:
            if isinstance(e.value, StreamError_Closed):
                if self.stream is not None:
                    self.stream.__exit__()
                    self.stream = None
                if self.body is not None:
                    IncomingBody.finish(self.body)
                    self.body = None
            else:
                raise e</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spin_sdk.http" href="index.html">spin_sdk.http</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="spin_sdk.http.poll_loop.register" href="#spin_sdk.http.poll_loop.register">register</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.send" href="#spin_sdk.http.poll_loop.send">send</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="spin_sdk.http.poll_loop.PollLoop" href="#spin_sdk.http.poll_loop.PollLoop">PollLoop</a></code></h4>
<ul class="">
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.add_reader" href="#spin_sdk.http.poll_loop.PollLoop.add_reader">add_reader</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.add_signal_handler" href="#spin_sdk.http.poll_loop.PollLoop.add_signal_handler">add_signal_handler</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.add_writer" href="#spin_sdk.http.poll_loop.PollLoop.add_writer">add_writer</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.call_at" href="#spin_sdk.http.poll_loop.PollLoop.call_at">call_at</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.call_exception_handler" href="#spin_sdk.http.poll_loop.PollLoop.call_exception_handler">call_exception_handler</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.call_later" href="#spin_sdk.http.poll_loop.PollLoop.call_later">call_later</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.call_soon" href="#spin_sdk.http.poll_loop.PollLoop.call_soon">call_soon</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.call_soon_threadsafe" href="#spin_sdk.http.poll_loop.PollLoop.call_soon_threadsafe">call_soon_threadsafe</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.close" href="#spin_sdk.http.poll_loop.PollLoop.close">close</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.connect_accepted_socket" href="#spin_sdk.http.poll_loop.PollLoop.connect_accepted_socket">connect_accepted_socket</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.connect_read_pipe" href="#spin_sdk.http.poll_loop.PollLoop.connect_read_pipe">connect_read_pipe</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.connect_write_pipe" href="#spin_sdk.http.poll_loop.PollLoop.connect_write_pipe">connect_write_pipe</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.create_connection" href="#spin_sdk.http.poll_loop.PollLoop.create_connection">create_connection</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.create_datagram_endpoint" href="#spin_sdk.http.poll_loop.PollLoop.create_datagram_endpoint">create_datagram_endpoint</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.create_future" href="#spin_sdk.http.poll_loop.PollLoop.create_future">create_future</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.create_server" href="#spin_sdk.http.poll_loop.PollLoop.create_server">create_server</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.create_task" href="#spin_sdk.http.poll_loop.PollLoop.create_task">create_task</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.create_unix_connection" href="#spin_sdk.http.poll_loop.PollLoop.create_unix_connection">create_unix_connection</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.create_unix_server" href="#spin_sdk.http.poll_loop.PollLoop.create_unix_server">create_unix_server</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.default_exception_handler" href="#spin_sdk.http.poll_loop.PollLoop.default_exception_handler">default_exception_handler</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.get_debug" href="#spin_sdk.http.poll_loop.PollLoop.get_debug">get_debug</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.get_exception_handler" href="#spin_sdk.http.poll_loop.PollLoop.get_exception_handler">get_exception_handler</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.get_task_factory" href="#spin_sdk.http.poll_loop.PollLoop.get_task_factory">get_task_factory</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.getaddrinfo" href="#spin_sdk.http.poll_loop.PollLoop.getaddrinfo">getaddrinfo</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.getnameinfo" href="#spin_sdk.http.poll_loop.PollLoop.getnameinfo">getnameinfo</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.is_closed" href="#spin_sdk.http.poll_loop.PollLoop.is_closed">is_closed</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.is_running" href="#spin_sdk.http.poll_loop.PollLoop.is_running">is_running</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.remove_reader" href="#spin_sdk.http.poll_loop.PollLoop.remove_reader">remove_reader</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.remove_signal_handler" href="#spin_sdk.http.poll_loop.PollLoop.remove_signal_handler">remove_signal_handler</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.remove_writer" href="#spin_sdk.http.poll_loop.PollLoop.remove_writer">remove_writer</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.run_forever" href="#spin_sdk.http.poll_loop.PollLoop.run_forever">run_forever</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.run_in_executor" href="#spin_sdk.http.poll_loop.PollLoop.run_in_executor">run_in_executor</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.run_until_complete" href="#spin_sdk.http.poll_loop.PollLoop.run_until_complete">run_until_complete</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.sendfile" href="#spin_sdk.http.poll_loop.PollLoop.sendfile">sendfile</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.set_debug" href="#spin_sdk.http.poll_loop.PollLoop.set_debug">set_debug</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.set_default_executor" href="#spin_sdk.http.poll_loop.PollLoop.set_default_executor">set_default_executor</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.set_exception_handler" href="#spin_sdk.http.poll_loop.PollLoop.set_exception_handler">set_exception_handler</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.set_task_factory" href="#spin_sdk.http.poll_loop.PollLoop.set_task_factory">set_task_factory</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.shutdown_asyncgens" href="#spin_sdk.http.poll_loop.PollLoop.shutdown_asyncgens">shutdown_asyncgens</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.shutdown_default_executor" href="#spin_sdk.http.poll_loop.PollLoop.shutdown_default_executor">shutdown_default_executor</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.sock_accept" href="#spin_sdk.http.poll_loop.PollLoop.sock_accept">sock_accept</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.sock_connect" href="#spin_sdk.http.poll_loop.PollLoop.sock_connect">sock_connect</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.sock_recv" href="#spin_sdk.http.poll_loop.PollLoop.sock_recv">sock_recv</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.sock_recv_into" href="#spin_sdk.http.poll_loop.PollLoop.sock_recv_into">sock_recv_into</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.sock_recvfrom" href="#spin_sdk.http.poll_loop.PollLoop.sock_recvfrom">sock_recvfrom</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.sock_recvfrom_into" href="#spin_sdk.http.poll_loop.PollLoop.sock_recvfrom_into">sock_recvfrom_into</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.sock_sendall" href="#spin_sdk.http.poll_loop.PollLoop.sock_sendall">sock_sendall</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.sock_sendfile" href="#spin_sdk.http.poll_loop.PollLoop.sock_sendfile">sock_sendfile</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.sock_sendto" href="#spin_sdk.http.poll_loop.PollLoop.sock_sendto">sock_sendto</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.start_tls" href="#spin_sdk.http.poll_loop.PollLoop.start_tls">start_tls</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.stop" href="#spin_sdk.http.poll_loop.PollLoop.stop">stop</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.subprocess_exec" href="#spin_sdk.http.poll_loop.PollLoop.subprocess_exec">subprocess_exec</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.subprocess_shell" href="#spin_sdk.http.poll_loop.PollLoop.subprocess_shell">subprocess_shell</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.PollLoop.time" href="#spin_sdk.http.poll_loop.PollLoop.time">time</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spin_sdk.http.poll_loop.Sink" href="#spin_sdk.http.poll_loop.Sink">Sink</a></code></h4>
<ul class="">
<li><code><a title="spin_sdk.http.poll_loop.Sink.close" href="#spin_sdk.http.poll_loop.Sink.close">close</a></code></li>
<li><code><a title="spin_sdk.http.poll_loop.Sink.send" href="#spin_sdk.http.poll_loop.Sink.send">send</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spin_sdk.http.poll_loop.Stream" href="#spin_sdk.http.poll_loop.Stream">Stream</a></code></h4>
<ul class="">
<li><code><a title="spin_sdk.http.poll_loop.Stream.next" href="#spin_sdk.http.poll_loop.Stream.next">next</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>