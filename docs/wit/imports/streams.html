<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>spin_sdk.wit.imports.streams API documentation</title>
<meta name="description" content="WASI I/O is an I/O abstraction API which is currently focused on providing
stream types â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spin_sdk.wit.imports.streams</code></h1>
</header>
<section id="section-intro">
<p>WASI I/O is an I/O abstraction API which is currently focused on providing
stream types.</p>
<p>In the future, the component model is expected to add built-in stream types;
when it does, they are expected to subsume this API.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
WASI I/O is an I/O abstraction API which is currently focused on providing
stream types.

In the future, the component model is expected to add built-in stream types;
when it does, they are expected to subsume this API.
&#34;&#34;&#34;
from typing import TypeVar, Generic, Union, Optional, Union, Protocol, Tuple, List, Any, Self
from enum import Flag, Enum, auto
from dataclasses import dataclass
from abc import abstractmethod
import weakref

from ..types import Result, Ok, Err, Some
from ..imports import poll
from ..imports import error


@dataclass
class StreamErrorLastOperationFailed:
    value: error.Error


@dataclass
class StreamErrorClosed:
    pass


StreamError = Union[StreamErrorLastOperationFailed, StreamErrorClosed]
&#34;&#34;&#34;
An error for input-stream and output-stream operations.
&#34;&#34;&#34;


class InputStream:
    &#34;&#34;&#34;
    An input bytestream.
    
    `input-stream`s are *non-blocking* to the extent practical on underlying
    platforms. I/O operations always return promptly; if fewer bytes are
    promptly available than requested, they return the number of bytes promptly
    available, which could even be zero. To wait for data to be available,
    use the `subscribe` function to obtain a `pollable` which can be polled
    for using `wasi:io/poll`.
    &#34;&#34;&#34;
    
    def read(self, len: int) -&gt; bytes:
        &#34;&#34;&#34;
        Perform a non-blocking read from the stream.
        
        When the source of a `read` is binary data, the bytes from the source
        are returned verbatim. When the source of a `read` is known to the
        implementation to be text, bytes containing the UTF-8 encoding of the
        text are returned.
        
        This function returns a list of bytes containing the read data,
        when successful. The returned list will contain up to `len` bytes;
        it may return fewer than requested, but not more. The list is
        empty when no bytes are available for reading at this time. The
        pollable given by `subscribe` will be ready when more bytes are
        available.
        
        This function fails with a `stream-error` when the operation
        encounters an error, giving `last-operation-failed`, or when the
        stream is closed, giving `closed`.
        
        When the caller gives a `len` of 0, it represents a request to
        read 0 bytes. If the stream is still open, this call should
        succeed and return an empty list, or otherwise fail with `closed`.
        
        The `len` parameter is a `u64`, which could represent a list of u8 which
        is not possible to allocate in wasm32, or not desirable to allocate as
        as a return value by the callee. The callee may return a list of bytes
        less than `len` in size while more bytes are available for reading.
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def blocking_read(self, len: int) -&gt; bytes:
        &#34;&#34;&#34;
        Read bytes from a stream, after blocking until at least one byte can
        be read. Except for blocking, behavior is identical to `read`.
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def skip(self, len: int) -&gt; int:
        &#34;&#34;&#34;
        Skip bytes from a stream. Returns number of bytes skipped.
        
        Behaves identical to `read`, except instead of returning a list
        of bytes, returns the number of bytes consumed from the stream.
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def blocking_skip(self, len: int) -&gt; int:
        &#34;&#34;&#34;
        Skip bytes from a stream, after blocking until at least one byte
        can be skipped. Except for blocking behavior, identical to `skip`.
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def subscribe(self) -&gt; poll.Pollable:
        &#34;&#34;&#34;
        Create a `pollable` which will resolve once either the specified stream
        has bytes available to read or the other end of the stream has been
        closed.
        The created `pollable` is a child resource of the `input-stream`.
        Implementations may trap if the `input-stream` is dropped before
        all derived `pollable`s created with this function are dropped.
        &#34;&#34;&#34;
        raise NotImplementedError

    def __enter__(self):
        &#34;&#34;&#34;Returns self&#34;&#34;&#34;
        return self
                                                                    
    def __exit__(self, *args):
        &#34;&#34;&#34;
        Release this resource.
        &#34;&#34;&#34;
        raise NotImplementedError


class OutputStream:
    &#34;&#34;&#34;
    An output bytestream.
    
    `output-stream`s are *non-blocking* to the extent practical on
    underlying platforms. Except where specified otherwise, I/O operations also
    always return promptly, after the number of bytes that can be written
    promptly, which could even be zero. To wait for the stream to be ready to
    accept data, the `subscribe` function to obtain a `pollable` which can be
    polled for using `wasi:io/poll`.
    &#34;&#34;&#34;
    
    def check_write(self) -&gt; int:
        &#34;&#34;&#34;
        Check readiness for writing. This function never blocks.
        
        Returns the number of bytes permitted for the next call to `write`,
        or an error. Calling `write` with more bytes than this function has
        permitted will trap.
        
        When this function returns 0 bytes, the `subscribe` pollable will
        become ready when this function will report at least 1 byte, or an
        error.
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def write(self, contents: bytes) -&gt; None:
        &#34;&#34;&#34;
        Perform a write. This function never blocks.
        
        When the destination of a `write` is binary data, the bytes from
        `contents` are written verbatim. When the destination of a `write` is
        known to the implementation to be text, the bytes of `contents` are
        transcoded from UTF-8 into the encoding of the destination and then
        written.
        
        Precondition: check-write gave permit of Ok(n) and contents has a
        length of less than or equal to n. Otherwise, this function will trap.
        
        returns Err(closed) without writing if the stream has closed since
        the last call to check-write provided a permit.
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def blocking_write_and_flush(self, contents: bytes) -&gt; None:
        &#34;&#34;&#34;
        Perform a write of up to 4096 bytes, and then flush the stream. Block
        until all of these operations are complete, or an error occurs.
        
        This is a convenience wrapper around the use of `check-write`,
        `subscribe`, `write`, and `flush`, and is implemented with the
        following pseudo-code:
        
        ```text
        let pollable = this.subscribe();
        while !contents.is_empty() {
        // Wait for the stream to become writable
        pollable.block();
        let Ok(n) = this.check-write(); // eliding error handling
        let len = min(n, contents.len());
        let (chunk, rest) = contents.split_at(len);
        this.write(chunk  );            // eliding error handling
        contents = rest;
        }
        this.flush();
        // Wait for completion of `flush`
        pollable.block();
        // Check for any errors that arose during `flush`
        let _ = this.check-write();         // eliding error handling
        ```
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def flush(self) -&gt; None:
        &#34;&#34;&#34;
        Request to flush buffered output. This function never blocks.
        
        This tells the output-stream that the caller intends any buffered
        output to be flushed. the output which is expected to be flushed
        is all that has been passed to `write` prior to this call.
        
        Upon calling this function, the `output-stream` will not accept any
        writes (`check-write` will return `ok(0)`) until the flush has
        completed. The `subscribe` pollable will become ready when the
        flush has completed and the stream can accept more writes.
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def blocking_flush(self) -&gt; None:
        &#34;&#34;&#34;
        Request to flush buffered output, and block until flush completes
        and stream is ready for writing again.
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def subscribe(self) -&gt; poll.Pollable:
        &#34;&#34;&#34;
        Create a `pollable` which will resolve once the output-stream
        is ready for more writing, or an error has occured. When this
        pollable is ready, `check-write` will return `ok(n)` with n&gt;0, or an
        error.
        
        If the stream is closed, this pollable is always ready immediately.
        
        The created `pollable` is a child resource of the `output-stream`.
        Implementations may trap if the `output-stream` is dropped before
        all derived `pollable`s created with this function are dropped.
        &#34;&#34;&#34;
        raise NotImplementedError

    def write_zeroes(self, len: int) -&gt; None:
        &#34;&#34;&#34;
        Write zeroes to a stream.
        
        This should be used precisely like `write` with the exact same
        preconditions (must use check-write first), but instead of
        passing a list of bytes, you simply pass the number of zero-bytes
        that should be written.
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def blocking_write_zeroes_and_flush(self, len: int) -&gt; None:
        &#34;&#34;&#34;
        Perform a write of up to 4096 zeroes, and then flush the stream.
        Block until all of these operations are complete, or an error
        occurs.
        
        This is a convenience wrapper around the use of `check-write`,
        `subscribe`, `write-zeroes`, and `flush`, and is implemented with
        the following pseudo-code:
        
        ```text
        let pollable = this.subscribe();
        while num_zeroes != 0 {
        // Wait for the stream to become writable
        pollable.block();
        let Ok(n) = this.check-write(); // eliding error handling
        let len = min(n, num_zeroes);
        this.write-zeroes(len);         // eliding error handling
        num_zeroes -= len;
        }
        this.flush();
        // Wait for completion of `flush`
        pollable.block();
        // Check for any errors that arose during `flush`
        let _ = this.check-write();         // eliding error handling
        ```
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def splice(self, src: InputStream, len: int) -&gt; int:
        &#34;&#34;&#34;
        Read from one stream and write to another.
        
        The behavior of splice is equivelant to:
        1. calling `check-write` on the `output-stream`
        2. calling `read` on the `input-stream` with the smaller of the
        `check-write` permitted length and the `len` provided to `splice`
        3. calling `write` on the `output-stream` with that read data.
        
        Any error reported by the call to `check-write`, `read`, or
        `write` ends the splice and reports that error.
        
        This function returns the number of bytes transferred; it may be less
        than `len`.
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def blocking_splice(self, src: InputStream, len: int) -&gt; int:
        &#34;&#34;&#34;
        Read from one stream and write to another, with blocking.
        
        This is similar to `splice`, except that it blocks until the
        `output-stream` is ready for writing, and the `input-stream`
        is ready for reading, before performing the `splice`.
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def __enter__(self):
        &#34;&#34;&#34;Returns self&#34;&#34;&#34;
        return self
                                                                    
    def __exit__(self, *args):
        &#34;&#34;&#34;
        Release this resource.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="spin_sdk.wit.imports.streams.StreamError"><code class="name">var <span class="ident">StreamError</span></code></dt>
<dd>
<div class="desc"><p>An error for input-stream and output-stream operations.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="spin_sdk.wit.imports.streams.InputStream"><code class="flex name class">
<span>class <span class="ident">InputStream</span></span>
</code></dt>
<dd>
<div class="desc"><p>An input bytestream.</p>
<p><code>input-stream</code>s are <em>non-blocking</em> to the extent practical on underlying
platforms. I/O operations always return promptly; if fewer bytes are
promptly available than requested, they return the number of bytes promptly
available, which could even be zero. To wait for data to be available,
use the <code>subscribe</code> function to obtain a <code>pollable</code> which can be polled
for using <code>wasi:io/poll</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InputStream:
    &#34;&#34;&#34;
    An input bytestream.
    
    `input-stream`s are *non-blocking* to the extent practical on underlying
    platforms. I/O operations always return promptly; if fewer bytes are
    promptly available than requested, they return the number of bytes promptly
    available, which could even be zero. To wait for data to be available,
    use the `subscribe` function to obtain a `pollable` which can be polled
    for using `wasi:io/poll`.
    &#34;&#34;&#34;
    
    def read(self, len: int) -&gt; bytes:
        &#34;&#34;&#34;
        Perform a non-blocking read from the stream.
        
        When the source of a `read` is binary data, the bytes from the source
        are returned verbatim. When the source of a `read` is known to the
        implementation to be text, bytes containing the UTF-8 encoding of the
        text are returned.
        
        This function returns a list of bytes containing the read data,
        when successful. The returned list will contain up to `len` bytes;
        it may return fewer than requested, but not more. The list is
        empty when no bytes are available for reading at this time. The
        pollable given by `subscribe` will be ready when more bytes are
        available.
        
        This function fails with a `stream-error` when the operation
        encounters an error, giving `last-operation-failed`, or when the
        stream is closed, giving `closed`.
        
        When the caller gives a `len` of 0, it represents a request to
        read 0 bytes. If the stream is still open, this call should
        succeed and return an empty list, or otherwise fail with `closed`.
        
        The `len` parameter is a `u64`, which could represent a list of u8 which
        is not possible to allocate in wasm32, or not desirable to allocate as
        as a return value by the callee. The callee may return a list of bytes
        less than `len` in size while more bytes are available for reading.
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def blocking_read(self, len: int) -&gt; bytes:
        &#34;&#34;&#34;
        Read bytes from a stream, after blocking until at least one byte can
        be read. Except for blocking, behavior is identical to `read`.
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def skip(self, len: int) -&gt; int:
        &#34;&#34;&#34;
        Skip bytes from a stream. Returns number of bytes skipped.
        
        Behaves identical to `read`, except instead of returning a list
        of bytes, returns the number of bytes consumed from the stream.
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def blocking_skip(self, len: int) -&gt; int:
        &#34;&#34;&#34;
        Skip bytes from a stream, after blocking until at least one byte
        can be skipped. Except for blocking behavior, identical to `skip`.
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def subscribe(self) -&gt; poll.Pollable:
        &#34;&#34;&#34;
        Create a `pollable` which will resolve once either the specified stream
        has bytes available to read or the other end of the stream has been
        closed.
        The created `pollable` is a child resource of the `input-stream`.
        Implementations may trap if the `input-stream` is dropped before
        all derived `pollable`s created with this function are dropped.
        &#34;&#34;&#34;
        raise NotImplementedError

    def __enter__(self):
        &#34;&#34;&#34;Returns self&#34;&#34;&#34;
        return self
                                                                    
    def __exit__(self, *args):
        &#34;&#34;&#34;
        Release this resource.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="spin_sdk.wit.imports.streams.InputStream.blocking_read"><code class="name flex">
<span>def <span class="ident">blocking_read</span></span>(<span>self, len:Â int) â€‘>Â bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Read bytes from a stream, after blocking until at least one byte can
be read. Except for blocking, behavior is identical to <code>read</code>.</p>
<p>Raises: <code><a title="spin_sdk.wit.types.Err" href="../types.html#spin_sdk.wit.types.Err">Err</a>(<a title="spin_sdk.wit.imports.streams.StreamError" href="#spin_sdk.wit.imports.streams.StreamError">StreamError</a>)</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blocking_read(self, len: int) -&gt; bytes:
    &#34;&#34;&#34;
    Read bytes from a stream, after blocking until at least one byte can
    be read. Except for blocking, behavior is identical to `read`.
    
    Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.wit.imports.streams.InputStream.blocking_skip"><code class="name flex">
<span>def <span class="ident">blocking_skip</span></span>(<span>self, len:Â int) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Skip bytes from a stream, after blocking until at least one byte
can be skipped. Except for blocking behavior, identical to <code>skip</code>.</p>
<p>Raises: <code><a title="spin_sdk.wit.types.Err" href="../types.html#spin_sdk.wit.types.Err">Err</a>(<a title="spin_sdk.wit.imports.streams.StreamError" href="#spin_sdk.wit.imports.streams.StreamError">StreamError</a>)</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blocking_skip(self, len: int) -&gt; int:
    &#34;&#34;&#34;
    Skip bytes from a stream, after blocking until at least one byte
    can be skipped. Except for blocking behavior, identical to `skip`.
    
    Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.wit.imports.streams.InputStream.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, len:Â int) â€‘>Â bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a non-blocking read from the stream.</p>
<p>When the source of a <code>read</code> is binary data, the bytes from the source
are returned verbatim. When the source of a <code>read</code> is known to the
implementation to be text, bytes containing the UTF-8 encoding of the
text are returned.</p>
<p>This function returns a list of bytes containing the read data,
when successful. The returned list will contain up to <code>len</code> bytes;
it may return fewer than requested, but not more. The list is
empty when no bytes are available for reading at this time. The
pollable given by <code>subscribe</code> will be ready when more bytes are
available.</p>
<p>This function fails with a <code>stream-error</code> when the operation
encounters an error, giving <code>last-operation-failed</code>, or when the
stream is closed, giving <code>closed</code>.</p>
<p>When the caller gives a <code>len</code> of 0, it represents a request to
read 0 bytes. If the stream is still open, this call should
succeed and return an empty list, or otherwise fail with <code>closed</code>.</p>
<p>The <code>len</code> parameter is a <code>u64</code>, which could represent a list of u8 which
is not possible to allocate in wasm32, or not desirable to allocate as
as a return value by the callee. The callee may return a list of bytes
less than <code>len</code> in size while more bytes are available for reading.</p>
<p>Raises: <code><a title="spin_sdk.wit.types.Err" href="../types.html#spin_sdk.wit.types.Err">Err</a>(<a title="spin_sdk.wit.imports.streams.StreamError" href="#spin_sdk.wit.imports.streams.StreamError">StreamError</a>)</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, len: int) -&gt; bytes:
    &#34;&#34;&#34;
    Perform a non-blocking read from the stream.
    
    When the source of a `read` is binary data, the bytes from the source
    are returned verbatim. When the source of a `read` is known to the
    implementation to be text, bytes containing the UTF-8 encoding of the
    text are returned.
    
    This function returns a list of bytes containing the read data,
    when successful. The returned list will contain up to `len` bytes;
    it may return fewer than requested, but not more. The list is
    empty when no bytes are available for reading at this time. The
    pollable given by `subscribe` will be ready when more bytes are
    available.
    
    This function fails with a `stream-error` when the operation
    encounters an error, giving `last-operation-failed`, or when the
    stream is closed, giving `closed`.
    
    When the caller gives a `len` of 0, it represents a request to
    read 0 bytes. If the stream is still open, this call should
    succeed and return an empty list, or otherwise fail with `closed`.
    
    The `len` parameter is a `u64`, which could represent a list of u8 which
    is not possible to allocate in wasm32, or not desirable to allocate as
    as a return value by the callee. The callee may return a list of bytes
    less than `len` in size while more bytes are available for reading.
    
    Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.wit.imports.streams.InputStream.skip"><code class="name flex">
<span>def <span class="ident">skip</span></span>(<span>self, len:Â int) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Skip bytes from a stream. Returns number of bytes skipped.</p>
<p>Behaves identical to <code>read</code>, except instead of returning a list
of bytes, returns the number of bytes consumed from the stream.</p>
<p>Raises: <code><a title="spin_sdk.wit.types.Err" href="../types.html#spin_sdk.wit.types.Err">Err</a>(<a title="spin_sdk.wit.imports.streams.StreamError" href="#spin_sdk.wit.imports.streams.StreamError">StreamError</a>)</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skip(self, len: int) -&gt; int:
    &#34;&#34;&#34;
    Skip bytes from a stream. Returns number of bytes skipped.
    
    Behaves identical to `read`, except instead of returning a list
    of bytes, returns the number of bytes consumed from the stream.
    
    Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.wit.imports.streams.InputStream.subscribe"><code class="name flex">
<span>def <span class="ident">subscribe</span></span>(<span>self) â€‘>Â <a title="spin_sdk.wit.imports.poll.Pollable" href="poll.html#spin_sdk.wit.imports.poll.Pollable">Pollable</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a <code>pollable</code> which will resolve once either the specified stream
has bytes available to read or the other end of the stream has been
closed.
The created <code>pollable</code> is a child resource of the <code>input-stream</code>.
Implementations may trap if the <code>input-stream</code> is dropped before
all derived <code>pollable</code>s created with this function are dropped.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subscribe(self) -&gt; poll.Pollable:
    &#34;&#34;&#34;
    Create a `pollable` which will resolve once either the specified stream
    has bytes available to read or the other end of the stream has been
    closed.
    The created `pollable` is a child resource of the `input-stream`.
    Implementations may trap if the `input-stream` is dropped before
    all derived `pollable`s created with this function are dropped.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spin_sdk.wit.imports.streams.OutputStream"><code class="flex name class">
<span>class <span class="ident">OutputStream</span></span>
</code></dt>
<dd>
<div class="desc"><p>An output bytestream.</p>
<p><code>output-stream</code>s are <em>non-blocking</em> to the extent practical on
underlying platforms. Except where specified otherwise, I/O operations also
always return promptly, after the number of bytes that can be written
promptly, which could even be zero. To wait for the stream to be ready to
accept data, the <code>subscribe</code> function to obtain a <code>pollable</code> which can be
polled for using <code>wasi:io/poll</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OutputStream:
    &#34;&#34;&#34;
    An output bytestream.
    
    `output-stream`s are *non-blocking* to the extent practical on
    underlying platforms. Except where specified otherwise, I/O operations also
    always return promptly, after the number of bytes that can be written
    promptly, which could even be zero. To wait for the stream to be ready to
    accept data, the `subscribe` function to obtain a `pollable` which can be
    polled for using `wasi:io/poll`.
    &#34;&#34;&#34;
    
    def check_write(self) -&gt; int:
        &#34;&#34;&#34;
        Check readiness for writing. This function never blocks.
        
        Returns the number of bytes permitted for the next call to `write`,
        or an error. Calling `write` with more bytes than this function has
        permitted will trap.
        
        When this function returns 0 bytes, the `subscribe` pollable will
        become ready when this function will report at least 1 byte, or an
        error.
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def write(self, contents: bytes) -&gt; None:
        &#34;&#34;&#34;
        Perform a write. This function never blocks.
        
        When the destination of a `write` is binary data, the bytes from
        `contents` are written verbatim. When the destination of a `write` is
        known to the implementation to be text, the bytes of `contents` are
        transcoded from UTF-8 into the encoding of the destination and then
        written.
        
        Precondition: check-write gave permit of Ok(n) and contents has a
        length of less than or equal to n. Otherwise, this function will trap.
        
        returns Err(closed) without writing if the stream has closed since
        the last call to check-write provided a permit.
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def blocking_write_and_flush(self, contents: bytes) -&gt; None:
        &#34;&#34;&#34;
        Perform a write of up to 4096 bytes, and then flush the stream. Block
        until all of these operations are complete, or an error occurs.
        
        This is a convenience wrapper around the use of `check-write`,
        `subscribe`, `write`, and `flush`, and is implemented with the
        following pseudo-code:
        
        ```text
        let pollable = this.subscribe();
        while !contents.is_empty() {
        // Wait for the stream to become writable
        pollable.block();
        let Ok(n) = this.check-write(); // eliding error handling
        let len = min(n, contents.len());
        let (chunk, rest) = contents.split_at(len);
        this.write(chunk  );            // eliding error handling
        contents = rest;
        }
        this.flush();
        // Wait for completion of `flush`
        pollable.block();
        // Check for any errors that arose during `flush`
        let _ = this.check-write();         // eliding error handling
        ```
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def flush(self) -&gt; None:
        &#34;&#34;&#34;
        Request to flush buffered output. This function never blocks.
        
        This tells the output-stream that the caller intends any buffered
        output to be flushed. the output which is expected to be flushed
        is all that has been passed to `write` prior to this call.
        
        Upon calling this function, the `output-stream` will not accept any
        writes (`check-write` will return `ok(0)`) until the flush has
        completed. The `subscribe` pollable will become ready when the
        flush has completed and the stream can accept more writes.
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def blocking_flush(self) -&gt; None:
        &#34;&#34;&#34;
        Request to flush buffered output, and block until flush completes
        and stream is ready for writing again.
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def subscribe(self) -&gt; poll.Pollable:
        &#34;&#34;&#34;
        Create a `pollable` which will resolve once the output-stream
        is ready for more writing, or an error has occured. When this
        pollable is ready, `check-write` will return `ok(n)` with n&gt;0, or an
        error.
        
        If the stream is closed, this pollable is always ready immediately.
        
        The created `pollable` is a child resource of the `output-stream`.
        Implementations may trap if the `output-stream` is dropped before
        all derived `pollable`s created with this function are dropped.
        &#34;&#34;&#34;
        raise NotImplementedError

    def write_zeroes(self, len: int) -&gt; None:
        &#34;&#34;&#34;
        Write zeroes to a stream.
        
        This should be used precisely like `write` with the exact same
        preconditions (must use check-write first), but instead of
        passing a list of bytes, you simply pass the number of zero-bytes
        that should be written.
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def blocking_write_zeroes_and_flush(self, len: int) -&gt; None:
        &#34;&#34;&#34;
        Perform a write of up to 4096 zeroes, and then flush the stream.
        Block until all of these operations are complete, or an error
        occurs.
        
        This is a convenience wrapper around the use of `check-write`,
        `subscribe`, `write-zeroes`, and `flush`, and is implemented with
        the following pseudo-code:
        
        ```text
        let pollable = this.subscribe();
        while num_zeroes != 0 {
        // Wait for the stream to become writable
        pollable.block();
        let Ok(n) = this.check-write(); // eliding error handling
        let len = min(n, num_zeroes);
        this.write-zeroes(len);         // eliding error handling
        num_zeroes -= len;
        }
        this.flush();
        // Wait for completion of `flush`
        pollable.block();
        // Check for any errors that arose during `flush`
        let _ = this.check-write();         // eliding error handling
        ```
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def splice(self, src: InputStream, len: int) -&gt; int:
        &#34;&#34;&#34;
        Read from one stream and write to another.
        
        The behavior of splice is equivelant to:
        1. calling `check-write` on the `output-stream`
        2. calling `read` on the `input-stream` with the smaller of the
        `check-write` permitted length and the `len` provided to `splice`
        3. calling `write` on the `output-stream` with that read data.
        
        Any error reported by the call to `check-write`, `read`, or
        `write` ends the splice and reports that error.
        
        This function returns the number of bytes transferred; it may be less
        than `len`.
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def blocking_splice(self, src: InputStream, len: int) -&gt; int:
        &#34;&#34;&#34;
        Read from one stream and write to another, with blocking.
        
        This is similar to `splice`, except that it blocks until the
        `output-stream` is ready for writing, and the `input-stream`
        is ready for reading, before performing the `splice`.
        
        Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
        &#34;&#34;&#34;
        raise NotImplementedError

    def __enter__(self):
        &#34;&#34;&#34;Returns self&#34;&#34;&#34;
        return self
                                                                    
    def __exit__(self, *args):
        &#34;&#34;&#34;
        Release this resource.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="spin_sdk.wit.imports.streams.OutputStream.blocking_flush"><code class="name flex">
<span>def <span class="ident">blocking_flush</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Request to flush buffered output, and block until flush completes
and stream is ready for writing again.</p>
<p>Raises: <code><a title="spin_sdk.wit.types.Err" href="../types.html#spin_sdk.wit.types.Err">Err</a>(<a title="spin_sdk.wit.imports.streams.StreamError" href="#spin_sdk.wit.imports.streams.StreamError">StreamError</a>)</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blocking_flush(self) -&gt; None:
    &#34;&#34;&#34;
    Request to flush buffered output, and block until flush completes
    and stream is ready for writing again.
    
    Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.wit.imports.streams.OutputStream.blocking_splice"><code class="name flex">
<span>def <span class="ident">blocking_splice</span></span>(<span>self, src:Â <a title="spin_sdk.wit.imports.streams.InputStream" href="#spin_sdk.wit.imports.streams.InputStream">InputStream</a>, len:Â int) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Read from one stream and write to another, with blocking.</p>
<p>This is similar to <code>splice</code>, except that it blocks until the
<code>output-stream</code> is ready for writing, and the <code>input-stream</code>
is ready for reading, before performing the <code>splice</code>.</p>
<p>Raises: <code><a title="spin_sdk.wit.types.Err" href="../types.html#spin_sdk.wit.types.Err">Err</a>(<a title="spin_sdk.wit.imports.streams.StreamError" href="#spin_sdk.wit.imports.streams.StreamError">StreamError</a>)</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blocking_splice(self, src: InputStream, len: int) -&gt; int:
    &#34;&#34;&#34;
    Read from one stream and write to another, with blocking.
    
    This is similar to `splice`, except that it blocks until the
    `output-stream` is ready for writing, and the `input-stream`
    is ready for reading, before performing the `splice`.
    
    Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.wit.imports.streams.OutputStream.blocking_write_and_flush"><code class="name flex">
<span>def <span class="ident">blocking_write_and_flush</span></span>(<span>self, contents:Â bytes) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a write of up to 4096 bytes, and then flush the stream. Block
until all of these operations are complete, or an error occurs.</p>
<p>This is a convenience wrapper around the use of <code>check-write</code>,
<code>subscribe</code>, <code>write</code>, and <code>flush</code>, and is implemented with the
following pseudo-code:</p>
<pre><code class="language-text">let pollable = this.subscribe();
while !contents.is_empty() {
// Wait for the stream to become writable
pollable.block();
let Ok(n) = this.check-write(); // eliding error handling
let len = min(n, contents.len());
let (chunk, rest) = contents.split_at(len);
this.write(chunk  );            // eliding error handling
contents = rest;
}
this.flush();
// Wait for completion of `flush`
pollable.block();
// Check for any errors that arose during `flush`
let _ = this.check-write();         // eliding error handling
</code></pre>
<p>Raises: <code><a title="spin_sdk.wit.types.Err" href="../types.html#spin_sdk.wit.types.Err">Err</a>(<a title="spin_sdk.wit.imports.streams.StreamError" href="#spin_sdk.wit.imports.streams.StreamError">StreamError</a>)</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blocking_write_and_flush(self, contents: bytes) -&gt; None:
    &#34;&#34;&#34;
    Perform a write of up to 4096 bytes, and then flush the stream. Block
    until all of these operations are complete, or an error occurs.
    
    This is a convenience wrapper around the use of `check-write`,
    `subscribe`, `write`, and `flush`, and is implemented with the
    following pseudo-code:
    
    ```text
    let pollable = this.subscribe();
    while !contents.is_empty() {
    // Wait for the stream to become writable
    pollable.block();
    let Ok(n) = this.check-write(); // eliding error handling
    let len = min(n, contents.len());
    let (chunk, rest) = contents.split_at(len);
    this.write(chunk  );            // eliding error handling
    contents = rest;
    }
    this.flush();
    // Wait for completion of `flush`
    pollable.block();
    // Check for any errors that arose during `flush`
    let _ = this.check-write();         // eliding error handling
    ```
    
    Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.wit.imports.streams.OutputStream.blocking_write_zeroes_and_flush"><code class="name flex">
<span>def <span class="ident">blocking_write_zeroes_and_flush</span></span>(<span>self, len:Â int) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a write of up to 4096 zeroes, and then flush the stream.
Block until all of these operations are complete, or an error
occurs.</p>
<p>This is a convenience wrapper around the use of <code>check-write</code>,
<code>subscribe</code>, <code>write-zeroes</code>, and <code>flush</code>, and is implemented with
the following pseudo-code:</p>
<pre><code class="language-text">let pollable = this.subscribe();
while num_zeroes != 0 {
// Wait for the stream to become writable
pollable.block();
let Ok(n) = this.check-write(); // eliding error handling
let len = min(n, num_zeroes);
this.write-zeroes(len);         // eliding error handling
num_zeroes -= len;
}
this.flush();
// Wait for completion of `flush`
pollable.block();
// Check for any errors that arose during `flush`
let _ = this.check-write();         // eliding error handling
</code></pre>
<p>Raises: <code><a title="spin_sdk.wit.types.Err" href="../types.html#spin_sdk.wit.types.Err">Err</a>(<a title="spin_sdk.wit.imports.streams.StreamError" href="#spin_sdk.wit.imports.streams.StreamError">StreamError</a>)</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blocking_write_zeroes_and_flush(self, len: int) -&gt; None:
    &#34;&#34;&#34;
    Perform a write of up to 4096 zeroes, and then flush the stream.
    Block until all of these operations are complete, or an error
    occurs.
    
    This is a convenience wrapper around the use of `check-write`,
    `subscribe`, `write-zeroes`, and `flush`, and is implemented with
    the following pseudo-code:
    
    ```text
    let pollable = this.subscribe();
    while num_zeroes != 0 {
    // Wait for the stream to become writable
    pollable.block();
    let Ok(n) = this.check-write(); // eliding error handling
    let len = min(n, num_zeroes);
    this.write-zeroes(len);         // eliding error handling
    num_zeroes -= len;
    }
    this.flush();
    // Wait for completion of `flush`
    pollable.block();
    // Check for any errors that arose during `flush`
    let _ = this.check-write();         // eliding error handling
    ```
    
    Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.wit.imports.streams.OutputStream.check_write"><code class="name flex">
<span>def <span class="ident">check_write</span></span>(<span>self) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Check readiness for writing. This function never blocks.</p>
<p>Returns the number of bytes permitted for the next call to <code>write</code>,
or an error. Calling <code>write</code> with more bytes than this function has
permitted will trap.</p>
<p>When this function returns 0 bytes, the <code>subscribe</code> pollable will
become ready when this function will report at least 1 byte, or an
error.</p>
<p>Raises: <code><a title="spin_sdk.wit.types.Err" href="../types.html#spin_sdk.wit.types.Err">Err</a>(<a title="spin_sdk.wit.imports.streams.StreamError" href="#spin_sdk.wit.imports.streams.StreamError">StreamError</a>)</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_write(self) -&gt; int:
    &#34;&#34;&#34;
    Check readiness for writing. This function never blocks.
    
    Returns the number of bytes permitted for the next call to `write`,
    or an error. Calling `write` with more bytes than this function has
    permitted will trap.
    
    When this function returns 0 bytes, the `subscribe` pollable will
    become ready when this function will report at least 1 byte, or an
    error.
    
    Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.wit.imports.streams.OutputStream.flush"><code class="name flex">
<span>def <span class="ident">flush</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Request to flush buffered output. This function never blocks.</p>
<p>This tells the output-stream that the caller intends any buffered
output to be flushed. the output which is expected to be flushed
is all that has been passed to <code>write</code> prior to this call.</p>
<p>Upon calling this function, the <code>output-stream</code> will not accept any
writes (<code>check-write</code> will return <code>ok(0)</code>) until the flush has
completed. The <code>subscribe</code> pollable will become ready when the
flush has completed and the stream can accept more writes.</p>
<p>Raises: <code><a title="spin_sdk.wit.types.Err" href="../types.html#spin_sdk.wit.types.Err">Err</a>(<a title="spin_sdk.wit.imports.streams.StreamError" href="#spin_sdk.wit.imports.streams.StreamError">StreamError</a>)</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flush(self) -&gt; None:
    &#34;&#34;&#34;
    Request to flush buffered output. This function never blocks.
    
    This tells the output-stream that the caller intends any buffered
    output to be flushed. the output which is expected to be flushed
    is all that has been passed to `write` prior to this call.
    
    Upon calling this function, the `output-stream` will not accept any
    writes (`check-write` will return `ok(0)`) until the flush has
    completed. The `subscribe` pollable will become ready when the
    flush has completed and the stream can accept more writes.
    
    Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.wit.imports.streams.OutputStream.splice"><code class="name flex">
<span>def <span class="ident">splice</span></span>(<span>self, src:Â <a title="spin_sdk.wit.imports.streams.InputStream" href="#spin_sdk.wit.imports.streams.InputStream">InputStream</a>, len:Â int) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Read from one stream and write to another.</p>
<p>The behavior of splice is equivelant to:
1. calling <code>check-write</code> on the <code>output-stream</code>
2. calling <code>read</code> on the <code>input-stream</code> with the smaller of the
<code>check-write</code> permitted length and the <code>len</code> provided to <code>splice</code>
3. calling <code>write</code> on the <code>output-stream</code> with that read data.</p>
<p>Any error reported by the call to <code>check-write</code>, <code>read</code>, or
<code>write</code> ends the splice and reports that error.</p>
<p>This function returns the number of bytes transferred; it may be less
than <code>len</code>.</p>
<p>Raises: <code><a title="spin_sdk.wit.types.Err" href="../types.html#spin_sdk.wit.types.Err">Err</a>(<a title="spin_sdk.wit.imports.streams.StreamError" href="#spin_sdk.wit.imports.streams.StreamError">StreamError</a>)</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def splice(self, src: InputStream, len: int) -&gt; int:
    &#34;&#34;&#34;
    Read from one stream and write to another.
    
    The behavior of splice is equivelant to:
    1. calling `check-write` on the `output-stream`
    2. calling `read` on the `input-stream` with the smaller of the
    `check-write` permitted length and the `len` provided to `splice`
    3. calling `write` on the `output-stream` with that read data.
    
    Any error reported by the call to `check-write`, `read`, or
    `write` ends the splice and reports that error.
    
    This function returns the number of bytes transferred; it may be less
    than `len`.
    
    Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.wit.imports.streams.OutputStream.subscribe"><code class="name flex">
<span>def <span class="ident">subscribe</span></span>(<span>self) â€‘>Â <a title="spin_sdk.wit.imports.poll.Pollable" href="poll.html#spin_sdk.wit.imports.poll.Pollable">Pollable</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a <code>pollable</code> which will resolve once the output-stream
is ready for more writing, or an error has occured. When this
pollable is ready, <code>check-write</code> will return <code>ok(n)</code> with n&gt;0, or an
error.</p>
<p>If the stream is closed, this pollable is always ready immediately.</p>
<p>The created <code>pollable</code> is a child resource of the <code>output-stream</code>.
Implementations may trap if the <code>output-stream</code> is dropped before
all derived <code>pollable</code>s created with this function are dropped.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subscribe(self) -&gt; poll.Pollable:
    &#34;&#34;&#34;
    Create a `pollable` which will resolve once the output-stream
    is ready for more writing, or an error has occured. When this
    pollable is ready, `check-write` will return `ok(n)` with n&gt;0, or an
    error.
    
    If the stream is closed, this pollable is always ready immediately.
    
    The created `pollable` is a child resource of the `output-stream`.
    Implementations may trap if the `output-stream` is dropped before
    all derived `pollable`s created with this function are dropped.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.wit.imports.streams.OutputStream.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, contents:Â bytes) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a write. This function never blocks.</p>
<p>When the destination of a <code>write</code> is binary data, the bytes from
<code>contents</code> are written verbatim. When the destination of a <code>write</code> is
known to the implementation to be text, the bytes of <code>contents</code> are
transcoded from UTF-8 into the encoding of the destination and then
written.</p>
<p>Precondition: check-write gave permit of Ok(n) and contents has a
length of less than or equal to n. Otherwise, this function will trap.</p>
<p>returns Err(closed) without writing if the stream has closed since
the last call to check-write provided a permit.</p>
<p>Raises: <code><a title="spin_sdk.wit.types.Err" href="../types.html#spin_sdk.wit.types.Err">Err</a>(<a title="spin_sdk.wit.imports.streams.StreamError" href="#spin_sdk.wit.imports.streams.StreamError">StreamError</a>)</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, contents: bytes) -&gt; None:
    &#34;&#34;&#34;
    Perform a write. This function never blocks.
    
    When the destination of a `write` is binary data, the bytes from
    `contents` are written verbatim. When the destination of a `write` is
    known to the implementation to be text, the bytes of `contents` are
    transcoded from UTF-8 into the encoding of the destination and then
    written.
    
    Precondition: check-write gave permit of Ok(n) and contents has a
    length of less than or equal to n. Otherwise, this function will trap.
    
    returns Err(closed) without writing if the stream has closed since
    the last call to check-write provided a permit.
    
    Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="spin_sdk.wit.imports.streams.OutputStream.write_zeroes"><code class="name flex">
<span>def <span class="ident">write_zeroes</span></span>(<span>self, len:Â int) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Write zeroes to a stream.</p>
<p>This should be used precisely like <code>write</code> with the exact same
preconditions (must use check-write first), but instead of
passing a list of bytes, you simply pass the number of zero-bytes
that should be written.</p>
<p>Raises: <code><a title="spin_sdk.wit.types.Err" href="../types.html#spin_sdk.wit.types.Err">Err</a>(<a title="spin_sdk.wit.imports.streams.StreamError" href="#spin_sdk.wit.imports.streams.StreamError">StreamError</a>)</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_zeroes(self, len: int) -&gt; None:
    &#34;&#34;&#34;
    Write zeroes to a stream.
    
    This should be used precisely like `write` with the exact same
    preconditions (must use check-write first), but instead of
    passing a list of bytes, you simply pass the number of zero-bytes
    that should be written.
    
    Raises: `spin_sdk.wit.types.Err(spin_sdk.wit.imports.streams.StreamError)`
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spin_sdk.wit.imports.streams.StreamErrorClosed"><code class="flex name class">
<span>class <span class="ident">StreamErrorClosed</span></span>
</code></dt>
<dd>
<div class="desc"><p>StreamErrorClosed()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class StreamErrorClosed:
    pass</code></pre>
</details>
</dd>
<dt id="spin_sdk.wit.imports.streams.StreamErrorLastOperationFailed"><code class="flex name class">
<span>class <span class="ident">StreamErrorLastOperationFailed</span></span>
<span>(</span><span>value:Â <a title="spin_sdk.wit.imports.error.Error" href="error.html#spin_sdk.wit.imports.error.Error">Error</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>StreamErrorLastOperationFailed(value: spin_sdk.wit.imports.error.Error)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class StreamErrorLastOperationFailed:
    value: error.Error</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="spin_sdk.wit.imports.streams.StreamErrorLastOperationFailed.value"><code class="name">var <span class="ident">value</span> :Â <a title="spin_sdk.wit.imports.error.Error" href="error.html#spin_sdk.wit.imports.error.Error">Error</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spin_sdk.wit.imports" href="index.html">spin_sdk.wit.imports</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="spin_sdk.wit.imports.streams.StreamError" href="#spin_sdk.wit.imports.streams.StreamError">StreamError</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="spin_sdk.wit.imports.streams.InputStream" href="#spin_sdk.wit.imports.streams.InputStream">InputStream</a></code></h4>
<ul class="">
<li><code><a title="spin_sdk.wit.imports.streams.InputStream.blocking_read" href="#spin_sdk.wit.imports.streams.InputStream.blocking_read">blocking_read</a></code></li>
<li><code><a title="spin_sdk.wit.imports.streams.InputStream.blocking_skip" href="#spin_sdk.wit.imports.streams.InputStream.blocking_skip">blocking_skip</a></code></li>
<li><code><a title="spin_sdk.wit.imports.streams.InputStream.read" href="#spin_sdk.wit.imports.streams.InputStream.read">read</a></code></li>
<li><code><a title="spin_sdk.wit.imports.streams.InputStream.skip" href="#spin_sdk.wit.imports.streams.InputStream.skip">skip</a></code></li>
<li><code><a title="spin_sdk.wit.imports.streams.InputStream.subscribe" href="#spin_sdk.wit.imports.streams.InputStream.subscribe">subscribe</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spin_sdk.wit.imports.streams.OutputStream" href="#spin_sdk.wit.imports.streams.OutputStream">OutputStream</a></code></h4>
<ul class="">
<li><code><a title="spin_sdk.wit.imports.streams.OutputStream.blocking_flush" href="#spin_sdk.wit.imports.streams.OutputStream.blocking_flush">blocking_flush</a></code></li>
<li><code><a title="spin_sdk.wit.imports.streams.OutputStream.blocking_splice" href="#spin_sdk.wit.imports.streams.OutputStream.blocking_splice">blocking_splice</a></code></li>
<li><code><a title="spin_sdk.wit.imports.streams.OutputStream.blocking_write_and_flush" href="#spin_sdk.wit.imports.streams.OutputStream.blocking_write_and_flush">blocking_write_and_flush</a></code></li>
<li><code><a title="spin_sdk.wit.imports.streams.OutputStream.blocking_write_zeroes_and_flush" href="#spin_sdk.wit.imports.streams.OutputStream.blocking_write_zeroes_and_flush">blocking_write_zeroes_and_flush</a></code></li>
<li><code><a title="spin_sdk.wit.imports.streams.OutputStream.check_write" href="#spin_sdk.wit.imports.streams.OutputStream.check_write">check_write</a></code></li>
<li><code><a title="spin_sdk.wit.imports.streams.OutputStream.flush" href="#spin_sdk.wit.imports.streams.OutputStream.flush">flush</a></code></li>
<li><code><a title="spin_sdk.wit.imports.streams.OutputStream.splice" href="#spin_sdk.wit.imports.streams.OutputStream.splice">splice</a></code></li>
<li><code><a title="spin_sdk.wit.imports.streams.OutputStream.subscribe" href="#spin_sdk.wit.imports.streams.OutputStream.subscribe">subscribe</a></code></li>
<li><code><a title="spin_sdk.wit.imports.streams.OutputStream.write" href="#spin_sdk.wit.imports.streams.OutputStream.write">write</a></code></li>
<li><code><a title="spin_sdk.wit.imports.streams.OutputStream.write_zeroes" href="#spin_sdk.wit.imports.streams.OutputStream.write_zeroes">write_zeroes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spin_sdk.wit.imports.streams.StreamErrorClosed" href="#spin_sdk.wit.imports.streams.StreamErrorClosed">StreamErrorClosed</a></code></h4>
</li>
<li>
<h4><code><a title="spin_sdk.wit.imports.streams.StreamErrorLastOperationFailed" href="#spin_sdk.wit.imports.streams.StreamErrorLastOperationFailed">StreamErrorLastOperationFailed</a></code></h4>
<ul class="">
<li><code><a title="spin_sdk.wit.imports.streams.StreamErrorLastOperationFailed.value" href="#spin_sdk.wit.imports.streams.StreamErrorLastOperationFailed.value">value</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>